{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n    AgentRuntime,\n    CacheManager,\n    CacheStore,\n    type Character,\n    type Client,\n    DbCacheAdapter,\n    defaultCharacter,\n    elizaLogger,\n    FsCacheAdapter,\n    type IAgentRuntime,\n    type ICacheManager,\n    type IDatabaseAdapter,\n    type IDatabaseCacheAdapter,\n    ModelProviderName,\n    parseBooleanFromText,\n    settings,\n    stringToUuid,\n    validateCharacterConfig,\n} from '@elizaos/core';\n\nimport { SqliteDatabaseAdapter } from '@elizaos/adapter-sqlite';\nimport { DirectClient } from '@elizaos/client-direct';\nimport { normalizeCharacter } from '@elizaos/plugin-di';\n\nimport Database from 'better-sqlite3';\nimport fs from 'fs';\nimport net from 'net';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport yargs from 'yargs';\n\ninterface JsonCharacter {\n    id: Character['id'];\n    name: Character['name'];\n    settings: Character['settings'];\n    style: Character['style'];\n    modelProvider: Character['modelProvider'];\n    bio: Character['bio'];\n    lore: Character['lore'];\n    messageExamples: Character['messageExamples'];\n    postExamples: Character['postExamples'];\n    topics: Character['topics'];\n    adjectives: Character['adjectives'];\n    clients: Character['clients'];\n\n    plugins: string[];\n    extends: string[];\n}\n\n// const __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\n// const __dirname = path.dirname(__filename); // get the name of the directory\nconst __dirname = process.cwd();\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n    const waitTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nconst logFetch = async (url: string, options: RequestInit) => {\n    elizaLogger.debug(`Fetching ${url}`);\n    // Disabled to avoid disclosure of sensitive information such as API keys\n    // elizaLogger.debug(JSON.stringify(options, null, 2));\n    return fetch(url, options);\n};\n\nexport function parseArguments(): {\n    character?: string;\n    characters?: string;\n} {\n    try {\n        return yargs(process.argv.slice(3))\n            .option('character', {\n                type: 'string',\n                description: 'Path to the character JSON file',\n            })\n            .option('characters', {\n                type: 'string',\n                description: 'Comma separated list of paths to character JSON files',\n            })\n            .parseSync();\n    } catch (error) {\n        elizaLogger.error('Error parsing arguments:', error);\n        return {};\n    }\n}\n\nfunction tryLoadFile(filePath: string): string | null {\n    try {\n        return fs.readFileSync(filePath, 'utf8');\n    } catch (e) {\n        elizaLogger.error(`Error loading file ${filePath}: ${e}`);\n        return null;\n    }\n}\n\nfunction mergeCharacters(base: Character, child: Character): Character {\n    const mergeObjects = (baseObj: any, childObj: any) => {\n        const result: any = {};\n        const keys = new Set([...Object.keys(baseObj || {}), ...Object.keys(childObj || {})]);\n\n        for (const key of keys) {\n            if (\n                typeof baseObj[key] === 'object' &&\n                typeof childObj[key] === 'object' &&\n                !Array.isArray(baseObj[key]) &&\n                !Array.isArray(childObj[key])\n            ) {\n                result[key] = mergeObjects(baseObj[key], childObj[key]);\n            } else if (Array.isArray(baseObj[key]) || Array.isArray(childObj[key])) {\n                result[key] = [...(baseObj[key] || []), ...(childObj[key] || [])];\n            } else {\n                result[key] = childObj[key] !== undefined ? childObj[key] : baseObj[key];\n            }\n        }\n\n        return result;\n    };\n    return mergeObjects(base, child);\n}\n\nasync function loadCharactersFromUrl(url: string): Promise<Character[]> {\n    try {\n        const response = await fetch(url);\n        const responseJson = await response.json();\n\n        let characters: Character[] = [];\n        if (Array.isArray(responseJson)) {\n            characters = await Promise.all(\n                responseJson.map((character) => jsonToCharacter(url, character)),\n            );\n        } else {\n            const character = await jsonToCharacter(url, responseJson);\n            characters.push(character);\n        }\n        return characters;\n    } catch (e) {\n        elizaLogger.error(`Error loading character(s) from ${url}: ${e}`);\n        process.exit(1);\n    }\n}\n\nasync function jsonToCharacter(filePath: string, character: JsonCharacter): Promise<Character> {\n    validateCharacterConfig(character);\n\n    // .id isn't really valid\n    const characterId = character.id || character.name;\n    const characterPrefix = `CHARACTER.${characterId.toUpperCase().replace(/ /g, '_')}.`;\n    const characterSettings = Object.entries(process.env)\n        .filter(([key]) => key.startsWith(characterPrefix))\n        .reduce((settings: Record<string, string>, [key, value]) => {\n            if (value) {\n                const settingKey = key.slice(characterPrefix.length);\n                settings[settingKey] = value;\n            }\n            return settings;\n        }, {});\n    if (Object.keys(characterSettings).length > 0) {\n        character.settings = character.settings || {};\n        character.settings.secrets = {\n            ...characterSettings,\n            ...character.settings.secrets,\n        };\n    }\n\n    // Handle plugins\n    const plugins = await handlePluginImporting(character.plugins);\n    let retCharacter: Character = { ...character, plugins };\n\n    if (character.extends) {\n        elizaLogger.info(`Merging  ${character.name} character with parent characters`);\n        for (const extendPath of character.extends) {\n            const baseCharacter = await loadCharacter(\n                path.resolve(path.dirname(filePath), extendPath),\n            );\n            retCharacter = mergeCharacters(baseCharacter, retCharacter);\n            elizaLogger.info(`Merged ${character.name} with ${baseCharacter.name}`);\n        }\n    }\n    return retCharacter;\n}\n\nasync function loadCharacter(filePath: string): Promise<Character> {\n    const content = tryLoadFile(filePath);\n    if (!content) {\n        throw new Error(`Character file not found: ${filePath}`);\n    }\n    const character = JSON.parse(content);\n    return jsonToCharacter(filePath, character);\n}\n\nasync function loadCharacterTryPath(characterPath: string): Promise<Character> {\n    let content: string | null = null;\n    let resolvedPath = '';\n\n    // Try different path resolutions in order\n    const pathsToTry = [\n        characterPath, // exact path as specified\n        path.resolve(process.cwd(), characterPath), // relative to cwd\n        path.resolve(process.cwd(), 'agent', characterPath), // Add this\n        path.resolve(__dirname, characterPath), // relative to current script\n        path.resolve(__dirname, 'characters', path.basename(characterPath)), // relative to agent/characters\n        path.resolve(__dirname, '../characters', path.basename(characterPath)), // relative to characters dir from agent\n        path.resolve(__dirname, '../../characters', path.basename(characterPath)), // relative to project root characters dir\n    ];\n\n    elizaLogger.info(\n        'Trying paths:',\n        pathsToTry.map((p) => ({\n            path: p,\n            exists: fs.existsSync(p),\n        })),\n    );\n\n    for (const tryPath of pathsToTry) {\n        content = tryLoadFile(tryPath);\n        if (content !== null) {\n            resolvedPath = tryPath;\n            break;\n        }\n    }\n\n    if (content === null) {\n        elizaLogger.error(\n            `Error loading character from ${characterPath}: File not found in any of the expected locations`,\n        );\n        elizaLogger.error('Tried the following paths:');\n        pathsToTry.forEach((p) => elizaLogger.error(` - ${p}`));\n        throw new Error(\n            `Error loading character from ${characterPath}: File not found in any of the expected locations`,\n        );\n    }\n    try {\n        const character: Character = await loadCharacter(resolvedPath);\n        elizaLogger.info(`Successfully loaded character from: ${resolvedPath}`);\n        return character;\n    } catch (e) {\n        elizaLogger.error(`Error parsing character from ${resolvedPath}: ${e}`);\n        throw new Error(`Error parsing character from ${resolvedPath}: ${e}`);\n    }\n}\n\nfunction commaSeparatedStringToArray(commaSeparated: string): string[] {\n    return commaSeparated?.split(',').map((value) => value.trim());\n}\n\nasync function readCharactersFromStorage(characterPaths: string[]): Promise<string[]> {\n    try {\n        const uploadDir = path.join(process.cwd(), 'data', 'characters');\n        await fs.promises.mkdir(uploadDir, { recursive: true });\n        const fileNames = await fs.promises.readdir(uploadDir);\n        fileNames.forEach((fileName) => {\n            characterPaths.push(path.join(uploadDir, fileName));\n        });\n    } catch (err: any) {\n        elizaLogger.error(`Error reading directory: ${err.message}`);\n    }\n\n    return characterPaths;\n}\n\nexport async function loadCharacters(charactersArg: string): Promise<Character[]> {\n    let characterPaths = commaSeparatedStringToArray(charactersArg);\n\n    if (process.env.USE_CHARACTER_STORAGE === 'true') {\n        characterPaths = await readCharactersFromStorage(characterPaths);\n    }\n\n    const loadedCharacters: Character[] = [];\n\n    if (characterPaths?.length > 0) {\n        for (const characterPath of characterPaths) {\n            try {\n                const character: Character = await loadCharacterTryPath(characterPath);\n                loadedCharacters.push(character);\n            } catch (e) {\n                elizaLogger.error(`Error load character: ${e}`);\n                process.exit(1);\n            }\n        }\n    }\n\n    if (hasValidRemoteUrls()) {\n        elizaLogger.info('Loading characters from remote URLs');\n        const characterUrls = commaSeparatedStringToArray(process.env.REMOTE_CHARACTER_URLS ?? '');\n        for (const characterUrl of characterUrls) {\n            const characters = await loadCharactersFromUrl(characterUrl);\n            loadedCharacters.push(...characters);\n        }\n    }\n\n    if (loadedCharacters.length === 0) {\n        elizaLogger.warn('No characters found, using default character');\n        loadedCharacters.push(defaultCharacter);\n    }\n\n    return loadedCharacters;\n}\n\nasync function handlePluginImporting(plugins: string[]) {\n    if (plugins.length > 0) {\n        elizaLogger.info('Plugins are: ', plugins);\n        const importedPlugins = await Promise.all(\n            plugins.map(async (plugin) => {\n                try {\n                    const importedPlugin = await import(plugin);\n                    const functionName = `${plugin\n                        .replace('@elizaos/plugin-', '')\n                        .replace(/-./g, (x) => x[1].toUpperCase())}Plugin`; // Assumes plugin function is camelCased with Plugin suffix\n                    return importedPlugin.default || importedPlugin[functionName];\n                } catch (importError) {\n                    elizaLogger.error(`Failed to import plugin: ${plugin}`, importError);\n                    return []; // Return null for failed imports\n                }\n            }),\n        );\n        return importedPlugins;\n    }\n\n    return [];\n}\n\nexport function getTokenForProvider(\n    provider: ModelProviderName,\n    character: Character,\n): string | undefined {\n    switch (provider) {\n        // no key needed for llama_local, ollama, lmstudio, gaianet or bedrock\n        case ModelProviderName.LLAMALOCAL:\n            return '';\n        case ModelProviderName.OLLAMA:\n            return '';\n        case ModelProviderName.LMSTUDIO:\n            return '';\n        case ModelProviderName.GAIANET:\n            return '';\n        case ModelProviderName.BEDROCK:\n            return '';\n        case ModelProviderName.OPENAI:\n            return character.settings?.secrets?.OPENAI_API_KEY || settings.OPENAI_API_KEY;\n        case ModelProviderName.ETERNALAI:\n            return character.settings?.secrets?.ETERNALAI_API_KEY || settings.ETERNALAI_API_KEY;\n        case ModelProviderName.NINETEEN_AI:\n            return character.settings?.secrets?.NINETEEN_AI_API_KEY || settings.NINETEEN_AI_API_KEY;\n        case ModelProviderName.LLAMACLOUD:\n        case ModelProviderName.TOGETHER:\n            return (\n                character.settings?.secrets?.LLAMACLOUD_API_KEY ||\n                settings.LLAMACLOUD_API_KEY ||\n                character.settings?.secrets?.TOGETHER_API_KEY ||\n                settings.TOGETHER_API_KEY ||\n                character.settings?.secrets?.OPENAI_API_KEY ||\n                settings.OPENAI_API_KEY\n            );\n        case ModelProviderName.CLAUDE_VERTEX:\n        case ModelProviderName.ANTHROPIC:\n            return (\n                character.settings?.secrets?.ANTHROPIC_API_KEY ||\n                character.settings?.secrets?.CLAUDE_API_KEY ||\n                settings.ANTHROPIC_API_KEY ||\n                settings.CLAUDE_API_KEY\n            );\n        case ModelProviderName.REDPILL:\n            return character.settings?.secrets?.REDPILL_API_KEY || settings.REDPILL_API_KEY;\n        case ModelProviderName.OPENROUTER:\n            return character.settings?.secrets?.OPENROUTER_API_KEY || settings.OPENROUTER_API_KEY;\n        case ModelProviderName.GROK:\n            return character.settings?.secrets?.GROK_API_KEY || settings.GROK_API_KEY;\n        case ModelProviderName.HEURIST:\n            return character.settings?.secrets?.HEURIST_API_KEY || settings.HEURIST_API_KEY;\n        case ModelProviderName.GROQ:\n            return character.settings?.secrets?.GROQ_API_KEY || settings.GROQ_API_KEY;\n        case ModelProviderName.GALADRIEL:\n            return character.settings?.secrets?.GALADRIEL_API_KEY || settings.GALADRIEL_API_KEY;\n        case ModelProviderName.FAL:\n            return character.settings?.secrets?.FAL_API_KEY || settings.FAL_API_KEY;\n        case ModelProviderName.ALI_BAILIAN:\n            return character.settings?.secrets?.ALI_BAILIAN_API_KEY || settings.ALI_BAILIAN_API_KEY;\n        case ModelProviderName.VOLENGINE:\n            return character.settings?.secrets?.VOLENGINE_API_KEY || settings.VOLENGINE_API_KEY;\n        case ModelProviderName.NANOGPT:\n            return character.settings?.secrets?.NANOGPT_API_KEY || settings.NANOGPT_API_KEY;\n        case ModelProviderName.HYPERBOLIC:\n            return character.settings?.secrets?.HYPERBOLIC_API_KEY || settings.HYPERBOLIC_API_KEY;\n\n        case ModelProviderName.VENICE:\n            return character.settings?.secrets?.VENICE_API_KEY || settings.VENICE_API_KEY;\n        case ModelProviderName.ATOMA:\n            return (\n                character.settings?.secrets?.ATOMASDK_BEARER_AUTH || settings.ATOMASDK_BEARER_AUTH\n            );\n        case ModelProviderName.NVIDIA:\n            return character.settings?.secrets?.NVIDIA_API_KEY || settings.NVIDIA_API_KEY;\n        case ModelProviderName.AKASH_CHAT_API:\n            return character.settings?.secrets?.AKASH_CHAT_API_KEY || settings.AKASH_CHAT_API_KEY;\n        case ModelProviderName.GOOGLE:\n            return (\n                character.settings?.secrets?.GOOGLE_GENERATIVE_AI_API_KEY ||\n                settings.GOOGLE_GENERATIVE_AI_API_KEY\n            );\n        case ModelProviderName.MISTRAL:\n            return character.settings?.secrets?.MISTRAL_API_KEY || settings.MISTRAL_API_KEY;\n        case ModelProviderName.LETZAI:\n            return character.settings?.secrets?.LETZAI_API_KEY || settings.LETZAI_API_KEY;\n        case ModelProviderName.INFERA:\n            return character.settings?.secrets?.INFERA_API_KEY || settings.INFERA_API_KEY;\n        case ModelProviderName.DEEPSEEK:\n            return character.settings?.secrets?.DEEPSEEK_API_KEY || settings.DEEPSEEK_API_KEY;\n        case ModelProviderName.LIVEPEER:\n            return (\n                character.settings?.secrets?.LIVEPEER_GATEWAY_URL || settings.LIVEPEER_GATEWAY_URL\n            );\n        default: {\n            const errorMessage = `Failed to get token - unsupported model provider: ${provider}`;\n            elizaLogger.error(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n}\n\n// also adds plugins from character file into the runtime\nexport async function initializeClients(character: Character, runtime: IAgentRuntime) {\n    // each client can only register once\n    // and if we want two we can explicitly support it\n    const clients: Record<string, unknown> = {};\n\n    function determineClientType(client: Client & { type?: string }): string {\n        // Check if client has a direct type identifier\n        if ('type' in client) {\n            return client.type ?? `client_${Date.now()}`;\n        }\n\n        // Check constructor name\n        const constructorName = client.constructor?.name;\n        if (constructorName && !constructorName.includes('Object')) {\n            return constructorName.toLowerCase().replace('client', '');\n        }\n\n        // Fallback: Generate a unique identifier\n        return `client_${Date.now()}`;\n    }\n\n    if (character.plugins?.length > 0) {\n        for (const plugin of character.plugins) {\n            if (plugin.clients) {\n                for (const client of plugin.clients) {\n                    const startedClient = await client.start(runtime);\n                    const clientType = determineClientType(client);\n                    elizaLogger.debug(`Initializing client of type: ${clientType}`);\n                    clients[clientType] = startedClient;\n                }\n            }\n        }\n    }\n\n    return clients;\n}\n\nfunction initializeDatabase(dataDir: string) {\n    const filePath = process.env.SQLITE_FILE ?? path.resolve(dataDir, 'db.sqlite');\n    elizaLogger.info(`Initializing SQLite database at ${filePath}...`);\n    const db = new SqliteDatabaseAdapter(new Database(filePath));\n\n    // Test the connection\n    db.init()\n        .then(() => {\n            elizaLogger.success('Successfully connected to SQLite database');\n        })\n        .catch((error) => {\n            elizaLogger.error('Failed to connect to SQLite:', error);\n        });\n\n    return db;\n}\n\nexport async function createAgent(\n    character: Character,\n    db: IDatabaseAdapter,\n    cache: ICacheManager,\n    token: string,\n): Promise<AgentRuntime> {\n    elizaLogger.log(`Creating runtime for character ${character.name}`);\n\n    return new AgentRuntime({\n        databaseAdapter: db,\n        token,\n        modelProvider: character.modelProvider,\n        evaluators: [],\n        character,\n        // character.plugins are handled when clients are added\n        plugins: [].flat().filter(Boolean),\n        providers: [],\n        managers: [],\n        cacheManager: cache,\n        fetch: logFetch,\n    });\n}\n\nfunction initializeFsCache(baseDir: string, character: Character) {\n    if (!character?.id) {\n        throw new Error('initializeFsCache requires id to be set in character definition');\n    }\n    const cacheDir = path.resolve(baseDir, character.id, 'cache');\n\n    const cache = new CacheManager(new FsCacheAdapter(cacheDir));\n    return cache;\n}\n\nfunction initializeDbCache(character: Character, db: IDatabaseCacheAdapter) {\n    if (!character?.id) {\n        throw new Error('initializeFsCache requires id to be set in character definition');\n    }\n    const cache = new CacheManager(new DbCacheAdapter(db, character.id));\n    return cache;\n}\n\nfunction initializeCache(\n    cacheStore: string,\n    character: Character,\n    baseDir?: string,\n    db?: IDatabaseCacheAdapter,\n) {\n    switch (cacheStore) {\n        case CacheStore.DATABASE:\n            if (db) {\n                elizaLogger.info('Using Database Cache...');\n                return initializeDbCache(character, db);\n            }\n\n            throw new Error('Database adapter is not provided for CacheStore.Database.');\n\n        case CacheStore.FILESYSTEM:\n            elizaLogger.info('Using File System Cache...');\n            if (!baseDir) {\n                throw new Error('baseDir must be provided for CacheStore.FILESYSTEM.');\n            }\n            return initializeFsCache(baseDir, character);\n\n        default:\n            throw new Error(\n                `Invalid cache store: ${cacheStore} or required configuration missing.`,\n            );\n    }\n}\n\nasync function startAgent(character: Character, directClient: DirectClient): Promise<AgentRuntime> {\n    let db: (IDatabaseAdapter & IDatabaseCacheAdapter) | undefined = undefined;\n\n    try {\n        character.id ??= stringToUuid(character.name);\n        character.username ??= character.name;\n\n        const token = getTokenForProvider(character.modelProvider, character);\n        const dataDir = path.join(__dirname, '../data');\n\n        if (!fs.existsSync(dataDir)) {\n            fs.mkdirSync(dataDir, { recursive: true });\n        }\n\n        db = initializeDatabase(dataDir) as IDatabaseAdapter & IDatabaseCacheAdapter;\n\n        await db.init();\n\n        const cache = initializeCache(\n            process.env.CACHE_STORE ?? CacheStore.FILESYSTEM,\n            character,\n            'data',\n            db,\n        ); // \"\" should be replaced with dir for file system caching. THOUGHTS: might probably make this into an env\n\n        const runtime: AgentRuntime = await createAgent(character, db, cache, token ?? '');\n\n        // start services/plugins/process knowledge\n        await runtime.initialize();\n\n        // start assigned clients\n        runtime.clients = await initializeClients(character, runtime);\n\n        // add to container\n        directClient.registerAgent(runtime);\n\n        // report to console\n        elizaLogger.debug(`Started ${character.name} as ${runtime.agentId}`);\n\n        return runtime;\n    } catch (error) {\n        elizaLogger.error(`Error starting agent for character ${character.name}: ${error}`);\n        // elizaLogger.error(error);\n        if (db) {\n            await db.close();\n        }\n        throw error;\n    }\n}\n\nconst checkPortAvailable = (port: number): Promise<boolean> => {\n    return new Promise((resolve) => {\n        const server = net.createServer();\n\n        server.once('error', (err: NodeJS.ErrnoException) => {\n            if (err.code === 'EADDRINUSE') {\n                resolve(false);\n            }\n        });\n\n        server.once('listening', () => {\n            server.close();\n            resolve(true);\n        });\n\n        server.listen(port);\n    });\n};\n\nconst hasValidRemoteUrls = () =>\n    process.env.REMOTE_CHARACTER_URLS &&\n    process.env.REMOTE_CHARACTER_URLS !== '' &&\n    process.env.REMOTE_CHARACTER_URLS.startsWith('http');\n\nexport const startAgents = async (plugins: { name: string; description: string }[]) => {\n    const directClient = new DirectClient();\n    let serverPort = Number.parseInt(settings.SERVER_PORT || '3000');\n    const args = parseArguments();\n    const charactersArg = args.characters || args.character;\n    let characters = [defaultCharacter];\n\n    defaultCharacter.plugins = plugins;\n    defaultCharacter.modelProvider = ModelProviderName.OPENAI;\n\n    if (charactersArg) {\n        characters = await loadCharacters(charactersArg);\n    }\n\n\n    // Normalize characters for injectable plugins\n    characters = await Promise.all(characters.map(normalizeCharacter));\n\n    try {\n        for (const character of characters) {\n            await startAgent(character, directClient);\n        }\n    } catch (error) {\n        elizaLogger.error('Error starting agents:', error);\n    }\n\n    // Find available port\n    while (!(await checkPortAvailable(serverPort))) {\n        elizaLogger.warn(`Port ${serverPort} is in use, trying ${serverPort + 1}`);\n        serverPort++;\n    }\n\n\n    // upload some agent functionality into directClient\n    directClient.startAgent = async (character: JsonCharacter) => {\n        // Handle plugins\n        const plugins = await handlePluginImporting(character.plugins);\n\n        // wrap it so we don't have to inject directClient later\n        return startAgent({ ...character, plugins }, directClient);\n    };\n\n    directClient.loadCharacterTryPath = loadCharacterTryPath;\n    directClient.jsonToCharacter = jsonToCharacter;\n\n    directClient.start(serverPort);\n\n    if (serverPort !== Number.parseInt(settings.SERVER_PORT || '3000')) {\n        elizaLogger.log(`Server started on alternate port ${serverPort}`);\n    }\n\n    elizaLogger.info(\n        'Run `pnpm start:client` to start the client and visit the outputted URL (http://localhost:5173) to chat with your agents. When running multiple agents, use client with different port `SERVER_PORT=3001 pnpm start:client`',\n    );\n};\n\n// startAgents().catch((error) => {\n//     elizaLogger.error('Unhandled error in startAgents:', error);\n//     process.exit(1);\n// });\n\n// Prevent unhandled exceptions from crashing the process if desired\nif (\n    process.env.PREVENT_UNHANDLED_EXIT &&\n    parseBooleanFromText(process.env.PREVENT_UNHANDLED_EXIT)\n) {\n    // Handle uncaught exceptions to prevent the process from crashing\n    process.on('uncaughtException', (err) => {\n        console.error('uncaughtException', err);\n    });\n\n    // Handle unhandled rejections to prevent the process from crashing\n    process.on('unhandledRejection', (err) => {\n        console.error('unhandledRejection', err);\n    });\n}\n"],"mappings":"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","names":["settings","plugins"]}